"""
–ì–ª–∞–≤–Ω—ã–π –º–æ–¥—É–ª—å —Å–∏—Å—Ç–µ–º—ã –ø–æ–∏—Å–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤ –¥–ª—è —Ç–µ–Ω–¥–µ—Ä–æ–≤
"""

import time
import json
from typing import Dict, Any, List

from app.services.attribute_matcher import create_matcher
from app.services.extractor import ConfigurableTermExtractor
from app.services.elasticsearch_service import ElasticsearchService
from app.services.semantic_search import SemanticSearchService

from app.config.settings import settings
from app.utils.logger import setup_logger


class TenderMatcher:
    """–û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤ –ø–æ —Ç–µ–Ω–¥–µ—Ä—É"""

    def __init__(self):
        self.logger = setup_logger(__name__)

        self.logger.info("=" * 80)
        self.logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –ø–æ–∏—Å–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤ –¥–ª—è —Ç–µ–Ω–¥–µ—Ä–æ–≤")
        self.logger.info("=" * 80)

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤
        self.logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤...")

        self.extractor = ConfigurableTermExtractor()
        self.es_service = ElasticsearchService()
        self.semantic_service = SemanticSearchService()

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –≥–∏–±—Ä–∏–¥–Ω—ã–π –º–∞—Ç—á–µ—Ä
        self.attribute_matcher = create_matcher()

        self.logger.info("–í—Å–µ —Å–µ—Ä–≤–∏—Å—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã")

        # –í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–∞—Ç—á–µ—Ä–µ
        if hasattr(self.attribute_matcher, 'use_cache'):
            cache_status = "–≤–∫–ª—é—á–µ–Ω" if self.attribute_matcher.use_cache else "–≤—ã–∫–ª—é—á–µ–Ω"
            self.logger.info(f"AttributeMatcher: –≥–∏–±—Ä–∏–¥–Ω—ã–π —Ä–µ–∂–∏–º, –∫—ç—à {cache_status}")

    def process_tender(self, tender: Dict[str, Any]) -> Dict[str, Any]:
        """
        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–Ω–¥–µ—Ä–∞

        –≠—Ç–∞–ø—ã:
        1. –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ—Ä–º–∏–Ω–æ–≤ –∏–∑ —Ç–µ–Ω–¥–µ—Ä–∞
        2. –ü–æ–∏—Å–∫ –≤ Elasticsearch (500k ‚Üí 2k)
        3. –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è (2k ‚Üí 500)
        4. –¢–æ—á–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ (500 ‚Üí —Ñ–∏–Ω–∞–ª—å–Ω—ã–µ)
        """

        start_time = time.time()
        tender_name = tender.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')

        self.logger.info("=" * 80)
        self.logger.info(f"–ù–ê–ß–ê–õ–û –û–ë–†–ê–ë–û–¢–ö–ò –¢–ï–ù–î–ï–†–ê: {tender_name}")
        self.logger.info("=" * 80)

        results = {
            'tender': tender,
            'stages': {},
            'final_products': [],
            'statistics': {},
            'execution_time': 0
        }

        try:
            # –≠–¢–ê–ü 1: –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ—Ä–º–∏–Ω–æ–≤
            self.logger.info("\nüìã –≠–¢–ê–ü 1: –ò–ó–í–õ–ï–ß–ï–ù–ò–ï –¢–ï–†–ú–ò–ù–û–í")
            self.logger.info("-" * 40)

            stage1_start = time.time()
            search_terms = self.extractor.extract_from_tender(tender)
            stage1_time = time.time() - stage1_start

            results['stages']['extraction'] = {
                'search_query': search_terms['search_query'],
                'boost_terms_count': len(search_terms['boost_terms']),
                'execution_time': stage1_time
            }

            self.logger.info(f"–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {stage1_time:.2f} —Å–µ–∫")

            # –≠–¢–ê–ü 2: –ü–æ–∏—Å–∫ –≤ Elasticsearch
            self.logger.info("\nüîç –≠–¢–ê–ü 2: –ü–û–ò–°–ö –í ELASTICSEARCH")
            self.logger.info("-" * 40)

            stage2_start = time.time()
            es_results = self.es_service.search_products(
                search_terms,
                size=settings.MAX_SEARCH_RESULTS
            )
            stage2_time = time.time() - stage2_start

            if 'error' in es_results:
                self.logger.error(f"–û—à–∏–±–∫–∞ Elasticsearch: {es_results['error']}")
                results['error'] = es_results['error']
                return results

            candidates = es_results.get('candidates', [])
            results['stages']['elasticsearch'] = {
                'total_found': es_results['total_found'],
                'candidates_retrieved': len(candidates),
                'max_score': es_results.get('max_score', 0),
                'execution_time': stage2_time
            }

            self.logger.info(f"Elasticsearch –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞ {stage2_time:.2f} —Å–µ–∫")
            self.logger.info(f"–ù–∞–π–¥–µ–Ω–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤: {len(candidates)} –∏–∑ {es_results['total_found']}")

            if not candidates:
                self.logger.warning("Elasticsearch –Ω–µ –Ω–∞—à–µ–ª –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Ç–æ–≤–∞—Ä–æ–≤")
                results['final_products'] = []
                return results

            # –≠–¢–ê–ü 3: –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è
            self.logger.info("\nüß† –≠–¢–ê–ü 3: –°–ï–ú–ê–ù–¢–ò–ß–ï–°–ö–ê–Ø –§–ò–õ–¨–¢–†–ê–¶–ò–Ø")
            self.logger.info("-" * 40)

            stage3_start = time.time()
            semantic_filtered = self.semantic_service.filter_by_similarity(
                tender,
                candidates,
                threshold=settings.SEMANTIC_THRESHOLD,
                top_k=settings.SEMANTIC_MAX_CANDIDATES
            )

            # –ö–æ–º–±–∏–Ω–∏—Ä—É–µ–º —Å–∫–æ—Ä—ã
            semantic_filtered = self.semantic_service.combine_with_es_scores(semantic_filtered)
            stage3_time = time.time() - stage3_start

            results['stages']['semantic'] = {
                'input_products': len(candidates),
                'filtered_products': len(semantic_filtered),
                'threshold_used': settings.SEMANTIC_THRESHOLD,
                'execution_time': stage3_time
            }

            self.logger.info(f"–°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∑–∞ {stage3_time:.2f} —Å–µ–∫")
            self.logger.info(f"–ü–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏: {len(semantic_filtered)} —Ç–æ–≤–∞—Ä–æ–≤")

            if not semantic_filtered:
                self.logger.warning("–°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –æ—Ç—Å–µ—è–ª–∞ –≤—Å–µ —Ç–æ–≤–∞—Ä—ã")
                results['final_products'] = []
                return results

            # –≠–¢–ê–ü 4: –¢–æ—á–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫
            self.logger.info("\n‚úÖ –≠–¢–ê–ü 4: –°–û–ü–û–°–¢–ê–í–õ–ï–ù–ò–ï –•–ê–†–ê–ö–¢–ï–†–ò–°–¢–ò–ö")
            self.logger.info("-" * 40)

            stage4_start = time.time()

            # –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤ –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è
            if len(semantic_filtered) > 50:
                self.logger.info("–ü—Ä–µ–¥–≤—ã—á–∏—Å–ª–µ–Ω–∏–µ —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤ –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è...")
                self.attribute_matcher.precompute_product_embeddings(
                    semantic_filtered[:100],  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
                    batch_size=50
                )

            final_products = []
            self.logger.info(f"–ü—Ä–æ–≤–µ—Ä–∫–∞ {len(semantic_filtered)} —Ç–æ–≤–∞—Ä–æ–≤...")

            for i, product in enumerate(semantic_filtered):
                # –õ–æ–≥–∏—Ä—É–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 10 —Ç–æ–≤–∞—Ä–æ–≤
                if i > 0 and i % 10 == 0:
                    self.logger.debug(f"–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {i}/{len(semantic_filtered)} —Ç–æ–≤–∞—Ä–æ–≤...")

                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –º–∞—Ç—á–µ—Ä
                match_result = self.attribute_matcher.match_product(tender, product)

                # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ —Ñ–æ—Ä–º–∞—Ç —Å—Ç–∞—Ä–æ–≥–æ –º–∞—Ç—á–µ—Ä–∞ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                if match_result.is_suitable:
                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º ProductMatch –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                    match_details = {
                        'score': match_result.score,
                        'confidence': match_result.score,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º score –∫–∞–∫ confidence
                        'matched_required': match_result.matched_required,
                        'total_required': match_result.total_required,
                        'matched_optional': match_result.matched_optional,
                        'total_optional': match_result.total_optional,
                        'match_percentage': match_result.match_percentage,
                        'is_suitable': match_result.is_suitable,
                        'processing_time': match_result.processing_time,
                        'details': [
                            {
                                'characteristic': m.tender_char,
                                'matched': m.matched,
                                'score': m.confidence,
                                'confidence': m.confidence,
                                'matched_with': m.product_attr,
                                'reason': m.reason,
                                'required': m.tender_char.get('required', False),
                                'match_type': m.match_type
                            }
                            for m in match_result.matches
                        ]
                    }

                    product['match_details'] = match_details
                    final_products.append(product)

                    self.logger.info(f"‚úì –¢–æ–≤–∞—Ä #{i+1} '{product['title'][:50]}...' –ü–û–î–•–û–î–ò–¢ "
                                   f"(—Å–∫–æ—Ä: {match_result.score:.2f})")

            stage4_time = time.time() - stage4_start

            results['stages']['attribute_matching'] = {
                'input_products': len(semantic_filtered),
                'matched_products': len(final_products),
                'execution_time': stage4_time
            }

            self.logger.info(f"–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {stage4_time:.2f} —Å–µ–∫")
            self.logger.info(f"–ù–∞–π–¥–µ–Ω–æ –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Ç–æ–≤–∞—Ä–æ–≤: {len(final_products)}")

            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–º—É —Å–∫–æ—Ä—É
            final_products.sort(
                key=lambda x: x.get('combined_score', 0),
                reverse=True
            )

            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            final_products = final_products[:settings.MAX_FINAL_RESULTS]

            results['final_products'] = final_products

            # –°–æ–±–∏—Ä–∞–µ–º –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            total_time = time.time() - start_time
            results['execution_time'] = total_time

            results['statistics'] = {
                'total_products_found': len(final_products),
                'stages_timing': {
                    'extraction': f"{stage1_time:.2f}s",
                    'elasticsearch': f"{stage2_time:.2f}s",
                    'semantic': f"{stage3_time:.2f}s",
                    'matching': f"{stage4_time:.2f}s"
                },
                'total_time': f"{total_time:.2f}s"
            }

            # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –º–∞—Ç—á–µ—Ä–∞
            if hasattr(self.attribute_matcher, 'get_stats'):
                matcher_stats = self.attribute_matcher.get_stats()
                results['statistics']['matcher_stats'] = matcher_stats

                # –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫—ç—à–∞
                if 'cache_hit_rate' in matcher_stats:
                    self.logger.info(f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫—ç—à–∞: {matcher_stats['cache_hit_rate']}")

            # –§–∏–Ω–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
            self.logger.info("\n" + "=" * 80)
            self.logger.info(f"–û–ë–†–ê–ë–û–¢–ö–ê –ó–ê–í–ï–†–®–ï–ù–ê")
            self.logger.info(f"–ù–∞–π–¥–µ–Ω–æ –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Ç–æ–≤–∞—Ä–æ–≤: {len(final_products)}")
            self.logger.info(f"–û–±—â–µ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {total_time:.2f} —Å–µ–∫—É–Ω–¥")
            self.logger.info("=" * 80 + "\n")

            # –õ–æ–≥–∏—Ä—É–µ–º —Ç–æ–ø-3 —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            if final_products:
                self.logger.info("–¢–û–ü-3 –†–ï–ó–£–õ–¨–¢–ê–¢–ê:")
                for i, product in enumerate(final_products[:3]):
                    self.logger.info(f"{i+1}. {product['title']}")
                    self.logger.info(f"   –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {product.get('category', '–ù/–î')}")
                    self.logger.info(f"   –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–∫–æ—Ä: {product.get('combined_score', 0):.3f}")
                    self.logger.info(f"   –°–æ–≤–ø–∞–¥–µ–Ω–∏–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫: {product['match_details']['match_percentage']:.1f}%")

        except Exception as e:
            self.logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç–µ–Ω–¥–µ—Ä–∞: {e}", exc_info=True)
            results['error'] = str(e)

        return results


def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""

    logger = setup_logger(__name__)

    # –ü—Ä–∏–º–µ—Ä —Ç–µ–Ω–¥–µ—Ä–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    tender_example = {
        "name": "–ö–∞–ª–µ–Ω–¥–∞—Ä—å –ø–µ—á–∞—Ç–Ω—ã–π",
        "characteristics": [
            {
                "name": "–í–∏–¥ –∫–∞–ª–µ–Ω–¥–∞—Ä—è",
                "value": "–ü–µ—Ä–µ–∫–∏–¥–Ω–æ–π",
                "type": "–ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–∞—è",
                "required": True
            },
            {
                "name": "–¢–∏–ø –∫–∞–ª–µ–Ω–¥–∞—Ä—è",
                "value": "–ù–∞—Å—Ç–µ–Ω–Ω—ã–π",
                "type": "–ö–æ–ª–∏—á–µ—Å—Ç–≤–µ–Ω–Ω–∞—è",
                "required": True
            },
        ]
    }

    try:
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã
        matcher = TenderMatcher()

        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–Ω–¥–µ—Ä–∞
        results = matcher.process_tender(tender_example)

        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        output_file = f"results_{int(time.time())}.json"
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2)

        logger.info(f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ —Ñ–∞–π–ª: {output_file}")

        # –í—ã–≤–æ–¥ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –º–∞—Ç—á–µ—Ä–∞
        if 'matcher_stats' in results.get('statistics', {}):
            logger.info("\n–°–¢–ê–¢–ò–°–¢–ò–ö–ê HYBRID ATTRIBUTE MATCHER:")
            stats = results['statistics']['matcher_stats']
            for key, value in stats.items():
                logger.info(f"  {key}: {value}")

        # –í—ã–≤–æ–¥ –∏—Ç–æ–≥–æ–≤–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
        logger.info(f"\n–ò–¢–û–ì–û:")
        logger.info(f"  –ù–∞–π–¥–µ–Ω–æ —Ç–æ–≤–∞—Ä–æ–≤: {results['statistics']['total_products_found']}")
        logger.info(f"  –û–±—â–µ–µ –≤—Ä–µ–º—è: {results['statistics']['total_time']}")

        # –î–µ—Ç–∞–ª–∏ –ø–æ —ç—Ç–∞–ø–∞–º
        logger.info(f"\n–í–†–ï–ú–Ø –ü–û –≠–¢–ê–ü–ê–ú:")
        for stage, timing in results['statistics']['stages_timing'].items():
            logger.info(f"  {stage}: {timing}")

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ: {e}", exc_info=True)


if __name__ == "__main__":
    main()